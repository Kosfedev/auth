// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/auth/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements mm_repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userData *model.NewUserData) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, userData *model.NewUserData)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.UserData, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserRepositoryMockGet

	funcPatch          func(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error)
	funcPatchOrigin    string
	inspectFuncPatch   func(ctx context.Context, userData *model.UpdatedUserData, id int64)
	afterPatchCounter  uint64
	beforePatchCounter uint64
	PatchMock          mUserRepositoryMockPatch
}

// NewUserRepositoryMock returns a mock for mm_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.GetMock = mUserRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserRepositoryMockGetParams{}

	m.PatchMock = mUserRepositoryMockPatch{mock: m}
	m.PatchMock.callArgs = []*UserRepositoryMockPatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockCreateParams
	paramPtrs          *UserRepositoryMockCreateParamPtrs
	expectationOrigins UserRepositoryMockCreateExpectationOrigins
	results            *UserRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx      context.Context
	userData *model.NewUserData
}

// UserRepositoryMockCreateParamPtrs contains pointers to parameters of the UserRepository.Create
type UserRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	userData **model.NewUserData
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// UserRepositoryMockCreateOrigins contains origins of expectations of the UserRepository.Create
type UserRepositoryMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserRepositoryMockCreate) Optional() *mUserRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, userData *model.NewUserData) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, userData}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserDataParam2 sets up expected param userData for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectUserDataParam2(userData *model.NewUserData) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userData = &userData
	mmCreate.defaultExpectation.expectationOrigins.originUserData = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, userData *model.NewUserData)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, userData *model.NewUserData) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, userData *model.NewUserData) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UserRepositoryMockCreateParams{ctx, userData},
		expectationOrigins: UserRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.Create should be invoked
func (mmCreate *mUserRepositoryMockCreate) Times(n uint64) *mUserRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUserRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, userData *model.NewUserData) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userData)
	}

	mm_params := UserRepositoryMockCreateParams{ctx, userData}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateParams{ctx, userData}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userData != nil && !minimock.Equal(*mm_want_ptrs.userData, mm_got.userData) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter userData, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUserData, *mm_want_ptrs.userData, mm_got.userData, minimock.Diff(*mm_want_ptrs.userData, mm_got.userData))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userData)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, userData)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUserRepositoryMockDelete struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockDeleteParams
	paramPtrs          *UserRepositoryMockDeleteParamPtrs
	expectationOrigins UserRepositoryMockDeleteExpectationOrigins
	results            *UserRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// UserRepositoryMockDeleteOrigins contains origins of expectations of the UserRepository.Delete
type UserRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserRepositoryMockDelete) Optional() *mUserRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectIdParam2(id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, id int64) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UserRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Delete should be invoked
func (mmDelete *mUserRepositoryMockDelete) Times(n uint64) *mUserRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserRepositoryMockGet struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetExpectation
	expectations       []*UserRepositoryMockGetExpectation

	callArgs []*UserRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetExpectation specifies expectation struct of the UserRepository.Get
type UserRepositoryMockGetExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetParams
	paramPtrs          *UserRepositoryMockGetParamPtrs
	expectationOrigins UserRepositoryMockGetExpectationOrigins
	results            *UserRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetParams contains parameters of the UserRepository.Get
type UserRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockGetParamPtrs contains pointers to parameters of the UserRepository.Get
type UserRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockGetResults contains results of the UserRepository.Get
type UserRepositoryMockGetResults struct {
	up1 *model.UserData
	err error
}

// UserRepositoryMockGetOrigins contains origins of expectations of the UserRepository.Get
type UserRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserRepositoryMockGet) Optional() *mUserRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Expect(ctx context.Context, id int64) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectIdParam2(id int64) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Return(up1 *model.UserData, err error) *UserRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserRepository.Get method
func (mmGet *mUserRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.UserData, err error)) *UserRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserRepositoryMockGet) When(ctx context.Context, id int64) *UserRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserRepositoryMockGetParams{ctx, id},
		expectationOrigins: UserRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetExpectation) Then(up1 *model.UserData, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.Get should be invoked
func (mmGet *mUserRepositoryMockGet) Times(n uint64) *mUserRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UserRepository
func (mmGet *UserRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.UserData, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserRepositoryMockGet) Calls() []*UserRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserRepositoryMockPatch struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockPatchExpectation
	expectations       []*UserRepositoryMockPatchExpectation

	callArgs []*UserRepositoryMockPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockPatchExpectation specifies expectation struct of the UserRepository.Patch
type UserRepositoryMockPatchExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockPatchParams
	paramPtrs          *UserRepositoryMockPatchParamPtrs
	expectationOrigins UserRepositoryMockPatchExpectationOrigins
	results            *UserRepositoryMockPatchResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockPatchParams contains parameters of the UserRepository.Patch
type UserRepositoryMockPatchParams struct {
	ctx      context.Context
	userData *model.UpdatedUserData
	id       int64
}

// UserRepositoryMockPatchParamPtrs contains pointers to parameters of the UserRepository.Patch
type UserRepositoryMockPatchParamPtrs struct {
	ctx      *context.Context
	userData **model.UpdatedUserData
	id       *int64
}

// UserRepositoryMockPatchResults contains results of the UserRepository.Patch
type UserRepositoryMockPatchResults struct {
	up1 *model.UserData
	err error
}

// UserRepositoryMockPatchOrigins contains origins of expectations of the UserRepository.Patch
type UserRepositoryMockPatchExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserData string
	originId       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatch *mUserRepositoryMockPatch) Optional() *mUserRepositoryMockPatch {
	mmPatch.optional = true
	return mmPatch
}

// Expect sets up expected params for UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) Expect(ctx context.Context, userData *model.UpdatedUserData, id int64) *mUserRepositoryMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserRepositoryMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.paramPtrs != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by ExpectParams functions")
	}

	mmPatch.defaultExpectation.params = &UserRepositoryMockPatchParams{ctx, userData, id}
	mmPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatch.expectations {
		if minimock.Equal(e.params, mmPatch.defaultExpectation.params) {
			mmPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatch.defaultExpectation.params)
		}
	}

	return mmPatch
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserRepositoryMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserRepositoryMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectUserDataParam2 sets up expected param userData for UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) ExpectUserDataParam2(userData *model.UpdatedUserData) *mUserRepositoryMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserRepositoryMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserRepositoryMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.userData = &userData
	mmPatch.defaultExpectation.expectationOrigins.originUserData = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectIdParam3 sets up expected param id for UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) ExpectIdParam3(id int64) *mUserRepositoryMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserRepositoryMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserRepositoryMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.id = &id
	mmPatch.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPatch
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) Inspect(f func(ctx context.Context, userData *model.UpdatedUserData, id int64)) *mUserRepositoryMockPatch {
	if mmPatch.mock.inspectFuncPatch != nil {
		mmPatch.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Patch")
	}

	mmPatch.mock.inspectFuncPatch = f

	return mmPatch
}

// Return sets up results that will be returned by UserRepository.Patch
func (mmPatch *mUserRepositoryMockPatch) Return(up1 *model.UserData, err error) *UserRepositoryMock {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserRepositoryMockPatchExpectation{mock: mmPatch.mock}
	}
	mmPatch.defaultExpectation.results = &UserRepositoryMockPatchResults{up1, err}
	mmPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// Set uses given function f to mock the UserRepository.Patch method
func (mmPatch *mUserRepositoryMockPatch) Set(f func(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error)) *UserRepositoryMock {
	if mmPatch.defaultExpectation != nil {
		mmPatch.mock.t.Fatalf("Default expectation is already set for the UserRepository.Patch method")
	}

	if len(mmPatch.expectations) > 0 {
		mmPatch.mock.t.Fatalf("Some expectations are already set for the UserRepository.Patch method")
	}

	mmPatch.mock.funcPatch = f
	mmPatch.mock.funcPatchOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// When sets expectation for the UserRepository.Patch which will trigger the result defined by the following
// Then helper
func (mmPatch *mUserRepositoryMockPatch) When(ctx context.Context, userData *model.UpdatedUserData, id int64) *UserRepositoryMockPatchExpectation {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserRepositoryMock.Patch mock is already set by Set")
	}

	expectation := &UserRepositoryMockPatchExpectation{
		mock:               mmPatch.mock,
		params:             &UserRepositoryMockPatchParams{ctx, userData, id},
		expectationOrigins: UserRepositoryMockPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatch.expectations = append(mmPatch.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Patch return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockPatchExpectation) Then(up1 *model.UserData, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockPatchResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.Patch should be invoked
func (mmPatch *mUserRepositoryMockPatch) Times(n uint64) *mUserRepositoryMockPatch {
	if n == 0 {
		mmPatch.mock.t.Fatalf("Times of UserRepositoryMock.Patch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatch.expectedInvocations, n)
	mmPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatch
}

func (mmPatch *mUserRepositoryMockPatch) invocationsDone() bool {
	if len(mmPatch.expectations) == 0 && mmPatch.defaultExpectation == nil && mmPatch.mock.funcPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatch.mock.afterPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Patch implements mm_repository.UserRepository
func (mmPatch *UserRepositoryMock) Patch(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error) {
	mm_atomic.AddUint64(&mmPatch.beforePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmPatch.afterPatchCounter, 1)

	mmPatch.t.Helper()

	if mmPatch.inspectFuncPatch != nil {
		mmPatch.inspectFuncPatch(ctx, userData, id)
	}

	mm_params := UserRepositoryMockPatchParams{ctx, userData, id}

	// Record call args
	mmPatch.PatchMock.mutex.Lock()
	mmPatch.PatchMock.callArgs = append(mmPatch.PatchMock.callArgs, &mm_params)
	mmPatch.PatchMock.mutex.Unlock()

	for _, e := range mmPatch.PatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmPatch.PatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatch.PatchMock.defaultExpectation.Counter, 1)
		mm_want := mmPatch.PatchMock.defaultExpectation.params
		mm_want_ptrs := mmPatch.PatchMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockPatchParams{ctx, userData, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatch.t.Errorf("UserRepositoryMock.Patch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userData != nil && !minimock.Equal(*mm_want_ptrs.userData, mm_got.userData) {
				mmPatch.t.Errorf("UserRepositoryMock.Patch got unexpected parameter userData, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originUserData, *mm_want_ptrs.userData, mm_got.userData, minimock.Diff(*mm_want_ptrs.userData, mm_got.userData))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPatch.t.Errorf("UserRepositoryMock.Patch got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatch.t.Errorf("UserRepositoryMock.Patch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatch.PatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatch.PatchMock.defaultExpectation.results
		if mm_results == nil {
			mmPatch.t.Fatal("No results are set for the UserRepositoryMock.Patch")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmPatch.funcPatch != nil {
		return mmPatch.funcPatch(ctx, userData, id)
	}
	mmPatch.t.Fatalf("Unexpected call to UserRepositoryMock.Patch. %v %v %v", ctx, userData, id)
	return
}

// PatchAfterCounter returns a count of finished UserRepositoryMock.Patch invocations
func (mmPatch *UserRepositoryMock) PatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.afterPatchCounter)
}

// PatchBeforeCounter returns a count of UserRepositoryMock.Patch invocations
func (mmPatch *UserRepositoryMock) PatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.beforePatchCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Patch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatch *mUserRepositoryMockPatch) Calls() []*UserRepositoryMockPatchParams {
	mmPatch.mutex.RLock()

	argCopy := make([]*UserRepositoryMockPatchParams, len(mmPatch.callArgs))
	copy(argCopy, mmPatch.callArgs)

	mmPatch.mutex.RUnlock()

	return argCopy
}

// MinimockPatchDone returns true if the count of the Patch invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockPatchDone() bool {
	if m.PatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchMock.invocationsDone()
}

// MinimockPatchInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockPatchInspect() {
	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Patch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchCounter := mm_atomic.LoadUint64(&m.afterPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchMock.defaultExpectation != nil && afterPatchCounter < 1 {
		if m.PatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.Patch at\n%s", m.PatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Patch at\n%s with params: %#v", m.PatchMock.defaultExpectation.expectationOrigins.origin, *m.PatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatch != nil && afterPatchCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.Patch at\n%s", m.funcPatchOrigin)
	}

	if !m.PatchMock.invocationsDone() && afterPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Patch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchMock.expectedInvocations), m.PatchMock.expectedInvocationsOrigin, afterPatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockPatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockPatchDone()
}

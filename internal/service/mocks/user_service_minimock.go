// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/auth/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserServiceMock implements mm_service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userData *model.NewUserData) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, userData *model.NewUserData)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserServiceMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserServiceMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.UserData, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserServiceMockGet

	funcPatch          func(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error)
	funcPatchOrigin    string
	inspectFuncPatch   func(ctx context.Context, userData *model.UpdatedUserData, id int64)
	afterPatchCounter  uint64
	beforePatchCounter uint64
	PatchMock          mUserServiceMockPatch
}

// NewUserServiceMock returns a mock for mm_service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserServiceMockCreateParams{}

	m.DeleteMock = mUserServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserServiceMockDeleteParams{}

	m.GetMock = mUserServiceMockGet{mock: m}
	m.GetMock.callArgs = []*UserServiceMockGetParams{}

	m.PatchMock = mUserServiceMockPatch{mock: m}
	m.PatchMock.callArgs = []*UserServiceMockPatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockCreate struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockCreateExpectation
	expectations       []*UserServiceMockCreateExpectation

	callArgs []*UserServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockCreateExpectation specifies expectation struct of the UserService.Create
type UserServiceMockCreateExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockCreateParams
	paramPtrs          *UserServiceMockCreateParamPtrs
	expectationOrigins UserServiceMockCreateExpectationOrigins
	results            *UserServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockCreateParams contains parameters of the UserService.Create
type UserServiceMockCreateParams struct {
	ctx      context.Context
	userData *model.NewUserData
}

// UserServiceMockCreateParamPtrs contains pointers to parameters of the UserService.Create
type UserServiceMockCreateParamPtrs struct {
	ctx      *context.Context
	userData **model.NewUserData
}

// UserServiceMockCreateResults contains results of the UserService.Create
type UserServiceMockCreateResults struct {
	i1  int64
	err error
}

// UserServiceMockCreateOrigins contains origins of expectations of the UserService.Create
type UserServiceMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserServiceMockCreate) Optional() *mUserServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserService.Create
func (mmCreate *mUserServiceMockCreate) Expect(ctx context.Context, userData *model.NewUserData) *mUserServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserServiceMockCreateParams{ctx, userData}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Create
func (mmCreate *mUserServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mUserServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserDataParam2 sets up expected param userData for UserService.Create
func (mmCreate *mUserServiceMockCreate) ExpectUserDataParam2(userData *model.NewUserData) *mUserServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userData = &userData
	mmCreate.defaultExpectation.expectationOrigins.originUserData = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserService.Create
func (mmCreate *mUserServiceMockCreate) Inspect(f func(ctx context.Context, userData *model.NewUserData)) *mUserServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserService.Create
func (mmCreate *mUserServiceMockCreate) Return(i1 int64, err error) *UserServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserServiceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UserService.Create method
func (mmCreate *mUserServiceMockCreate) Set(f func(ctx context.Context, userData *model.NewUserData) (i1 int64, err error)) *UserServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UserService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserServiceMockCreate) When(ctx context.Context, userData *model.NewUserData) *UserServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	expectation := &UserServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UserServiceMockCreateParams{ctx, userData},
		expectationOrigins: UserServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserService.Create return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCreateExpectation) Then(i1 int64, err error) *UserServiceMock {
	e.results = &UserServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserService.Create should be invoked
func (mmCreate *mUserServiceMockCreate) Times(n uint64) *mUserServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUserServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.UserService
func (mmCreate *UserServiceMock) Create(ctx context.Context, userData *model.NewUserData) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userData)
	}

	mm_params := UserServiceMockCreateParams{ctx, userData}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockCreateParams{ctx, userData}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userData != nil && !minimock.Equal(*mm_want_ptrs.userData, mm_got.userData) {
				mmCreate.t.Errorf("UserServiceMock.Create got unexpected parameter userData, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUserData, *mm_want_ptrs.userData, mm_got.userData, minimock.Diff(*mm_want_ptrs.userData, mm_got.userData))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userData)
	}
	mmCreate.t.Fatalf("Unexpected call to UserServiceMock.Create. %v %v", ctx, userData)
	return
}

// CreateAfterCounter returns a count of finished UserServiceMock.Create invocations
func (mmCreate *UserServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserServiceMock.Create invocations
func (mmCreate *UserServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserServiceMockCreate) Calls() []*UserServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUserServiceMockDelete struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockDeleteExpectation
	expectations       []*UserServiceMockDeleteExpectation

	callArgs []*UserServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockDeleteExpectation specifies expectation struct of the UserService.Delete
type UserServiceMockDeleteExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockDeleteParams
	paramPtrs          *UserServiceMockDeleteParamPtrs
	expectationOrigins UserServiceMockDeleteExpectationOrigins
	results            *UserServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockDeleteParams contains parameters of the UserService.Delete
type UserServiceMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserServiceMockDeleteParamPtrs contains pointers to parameters of the UserService.Delete
type UserServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserServiceMockDeleteResults contains results of the UserService.Delete
type UserServiceMockDeleteResults struct {
	err error
}

// UserServiceMockDeleteOrigins contains origins of expectations of the UserService.Delete
type UserServiceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserServiceMockDelete) Optional() *mUserServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserService.Delete
func (mmDelete *mUserServiceMockDelete) Expect(ctx context.Context, id int64) *mUserServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserServiceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Delete
func (mmDelete *mUserServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mUserServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserService.Delete
func (mmDelete *mUserServiceMockDelete) ExpectIdParam2(id int64) *mUserServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserService.Delete
func (mmDelete *mUserServiceMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserService.Delete
func (mmDelete *mUserServiceMockDelete) Return(err error) *UserServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserService.Delete method
func (mmDelete *mUserServiceMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserServiceMockDelete) When(ctx context.Context, id int64) *UserServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	expectation := &UserServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserServiceMockDeleteParams{ctx, id},
		expectationOrigins: UserServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserService.Delete return parameters for the expectation previously defined by the When method
func (e *UserServiceMockDeleteExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserService.Delete should be invoked
func (mmDelete *mUserServiceMockDelete) Times(n uint64) *mUserServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_service.UserService
func (mmDelete *UserServiceMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserServiceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserServiceMock.Delete invocations
func (mmDelete *UserServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserServiceMock.Delete invocations
func (mmDelete *UserServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserServiceMockDelete) Calls() []*UserServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserServiceMockGet struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetExpectation
	expectations       []*UserServiceMockGetExpectation

	callArgs []*UserServiceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockGetExpectation specifies expectation struct of the UserService.Get
type UserServiceMockGetExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockGetParams
	paramPtrs          *UserServiceMockGetParamPtrs
	expectationOrigins UserServiceMockGetExpectationOrigins
	results            *UserServiceMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockGetParams contains parameters of the UserService.Get
type UserServiceMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserServiceMockGetParamPtrs contains pointers to parameters of the UserService.Get
type UserServiceMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserServiceMockGetResults contains results of the UserService.Get
type UserServiceMockGetResults struct {
	up1 *model.UserData
	err error
}

// UserServiceMockGetOrigins contains origins of expectations of the UserService.Get
type UserServiceMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserServiceMockGet) Optional() *mUserServiceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserService.Get
func (mmGet *mUserServiceMockGet) Expect(ctx context.Context, id int64) *mUserServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserServiceMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Get
func (mmGet *mUserServiceMockGet) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserService.Get
func (mmGet *mUserServiceMockGet) ExpectIdParam2(id int64) *mUserServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserService.Get
func (mmGet *mUserServiceMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserService.Get
func (mmGet *mUserServiceMockGet) Return(up1 *model.UserData, err error) *UserServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserServiceMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserService.Get method
func (mmGet *mUserServiceMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.UserData, err error)) *UserServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserService.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserService.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserService.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserServiceMockGet) When(ctx context.Context, id int64) *UserServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	expectation := &UserServiceMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserServiceMockGetParams{ctx, id},
		expectationOrigins: UserServiceMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserService.Get return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetExpectation) Then(up1 *model.UserData, err error) *UserServiceMock {
	e.results = &UserServiceMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserService.Get should be invoked
func (mmGet *mUserServiceMockGet) Times(n uint64) *mUserServiceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserServiceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserServiceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_service.UserService
func (mmGet *UserServiceMock) Get(ctx context.Context, id int64) (up1 *model.UserData, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserServiceMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserServiceMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserServiceMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserServiceMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserServiceMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserServiceMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserServiceMock.Get invocations
func (mmGet *UserServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserServiceMock.Get invocations
func (mmGet *UserServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserServiceMockGet) Calls() []*UserServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserServiceMockPatch struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockPatchExpectation
	expectations       []*UserServiceMockPatchExpectation

	callArgs []*UserServiceMockPatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockPatchExpectation specifies expectation struct of the UserService.Patch
type UserServiceMockPatchExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockPatchParams
	paramPtrs          *UserServiceMockPatchParamPtrs
	expectationOrigins UserServiceMockPatchExpectationOrigins
	results            *UserServiceMockPatchResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockPatchParams contains parameters of the UserService.Patch
type UserServiceMockPatchParams struct {
	ctx      context.Context
	userData *model.UpdatedUserData
	id       int64
}

// UserServiceMockPatchParamPtrs contains pointers to parameters of the UserService.Patch
type UserServiceMockPatchParamPtrs struct {
	ctx      *context.Context
	userData **model.UpdatedUserData
	id       *int64
}

// UserServiceMockPatchResults contains results of the UserService.Patch
type UserServiceMockPatchResults struct {
	up1 *model.UserData
	err error
}

// UserServiceMockPatchOrigins contains origins of expectations of the UserService.Patch
type UserServiceMockPatchExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserData string
	originId       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatch *mUserServiceMockPatch) Optional() *mUserServiceMockPatch {
	mmPatch.optional = true
	return mmPatch
}

// Expect sets up expected params for UserService.Patch
func (mmPatch *mUserServiceMockPatch) Expect(ctx context.Context, userData *model.UpdatedUserData, id int64) *mUserServiceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserServiceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.paramPtrs != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by ExpectParams functions")
	}

	mmPatch.defaultExpectation.params = &UserServiceMockPatchParams{ctx, userData, id}
	mmPatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatch.expectations {
		if minimock.Equal(e.params, mmPatch.defaultExpectation.params) {
			mmPatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatch.defaultExpectation.params)
		}
	}

	return mmPatch
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Patch
func (mmPatch *mUserServiceMockPatch) ExpectCtxParam1(ctx context.Context) *mUserServiceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserServiceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserServiceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectUserDataParam2 sets up expected param userData for UserService.Patch
func (mmPatch *mUserServiceMockPatch) ExpectUserDataParam2(userData *model.UpdatedUserData) *mUserServiceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserServiceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserServiceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.userData = &userData
	mmPatch.defaultExpectation.expectationOrigins.originUserData = minimock.CallerInfo(1)

	return mmPatch
}

// ExpectIdParam3 sets up expected param id for UserService.Patch
func (mmPatch *mUserServiceMockPatch) ExpectIdParam3(id int64) *mUserServiceMockPatch {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserServiceMockPatchExpectation{}
	}

	if mmPatch.defaultExpectation.params != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Expect")
	}

	if mmPatch.defaultExpectation.paramPtrs == nil {
		mmPatch.defaultExpectation.paramPtrs = &UserServiceMockPatchParamPtrs{}
	}
	mmPatch.defaultExpectation.paramPtrs.id = &id
	mmPatch.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPatch
}

// Inspect accepts an inspector function that has same arguments as the UserService.Patch
func (mmPatch *mUserServiceMockPatch) Inspect(f func(ctx context.Context, userData *model.UpdatedUserData, id int64)) *mUserServiceMockPatch {
	if mmPatch.mock.inspectFuncPatch != nil {
		mmPatch.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Patch")
	}

	mmPatch.mock.inspectFuncPatch = f

	return mmPatch
}

// Return sets up results that will be returned by UserService.Patch
func (mmPatch *mUserServiceMockPatch) Return(up1 *model.UserData, err error) *UserServiceMock {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	if mmPatch.defaultExpectation == nil {
		mmPatch.defaultExpectation = &UserServiceMockPatchExpectation{mock: mmPatch.mock}
	}
	mmPatch.defaultExpectation.results = &UserServiceMockPatchResults{up1, err}
	mmPatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// Set uses given function f to mock the UserService.Patch method
func (mmPatch *mUserServiceMockPatch) Set(f func(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error)) *UserServiceMock {
	if mmPatch.defaultExpectation != nil {
		mmPatch.mock.t.Fatalf("Default expectation is already set for the UserService.Patch method")
	}

	if len(mmPatch.expectations) > 0 {
		mmPatch.mock.t.Fatalf("Some expectations are already set for the UserService.Patch method")
	}

	mmPatch.mock.funcPatch = f
	mmPatch.mock.funcPatchOrigin = minimock.CallerInfo(1)
	return mmPatch.mock
}

// When sets expectation for the UserService.Patch which will trigger the result defined by the following
// Then helper
func (mmPatch *mUserServiceMockPatch) When(ctx context.Context, userData *model.UpdatedUserData, id int64) *UserServiceMockPatchExpectation {
	if mmPatch.mock.funcPatch != nil {
		mmPatch.mock.t.Fatalf("UserServiceMock.Patch mock is already set by Set")
	}

	expectation := &UserServiceMockPatchExpectation{
		mock:               mmPatch.mock,
		params:             &UserServiceMockPatchParams{ctx, userData, id},
		expectationOrigins: UserServiceMockPatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatch.expectations = append(mmPatch.expectations, expectation)
	return expectation
}

// Then sets up UserService.Patch return parameters for the expectation previously defined by the When method
func (e *UserServiceMockPatchExpectation) Then(up1 *model.UserData, err error) *UserServiceMock {
	e.results = &UserServiceMockPatchResults{up1, err}
	return e.mock
}

// Times sets number of times UserService.Patch should be invoked
func (mmPatch *mUserServiceMockPatch) Times(n uint64) *mUserServiceMockPatch {
	if n == 0 {
		mmPatch.mock.t.Fatalf("Times of UserServiceMock.Patch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatch.expectedInvocations, n)
	mmPatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatch
}

func (mmPatch *mUserServiceMockPatch) invocationsDone() bool {
	if len(mmPatch.expectations) == 0 && mmPatch.defaultExpectation == nil && mmPatch.mock.funcPatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatch.mock.afterPatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Patch implements mm_service.UserService
func (mmPatch *UserServiceMock) Patch(ctx context.Context, userData *model.UpdatedUserData, id int64) (up1 *model.UserData, err error) {
	mm_atomic.AddUint64(&mmPatch.beforePatchCounter, 1)
	defer mm_atomic.AddUint64(&mmPatch.afterPatchCounter, 1)

	mmPatch.t.Helper()

	if mmPatch.inspectFuncPatch != nil {
		mmPatch.inspectFuncPatch(ctx, userData, id)
	}

	mm_params := UserServiceMockPatchParams{ctx, userData, id}

	// Record call args
	mmPatch.PatchMock.mutex.Lock()
	mmPatch.PatchMock.callArgs = append(mmPatch.PatchMock.callArgs, &mm_params)
	mmPatch.PatchMock.mutex.Unlock()

	for _, e := range mmPatch.PatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmPatch.PatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatch.PatchMock.defaultExpectation.Counter, 1)
		mm_want := mmPatch.PatchMock.defaultExpectation.params
		mm_want_ptrs := mmPatch.PatchMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockPatchParams{ctx, userData, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatch.t.Errorf("UserServiceMock.Patch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userData != nil && !minimock.Equal(*mm_want_ptrs.userData, mm_got.userData) {
				mmPatch.t.Errorf("UserServiceMock.Patch got unexpected parameter userData, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originUserData, *mm_want_ptrs.userData, mm_got.userData, minimock.Diff(*mm_want_ptrs.userData, mm_got.userData))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPatch.t.Errorf("UserServiceMock.Patch got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatch.PatchMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatch.t.Errorf("UserServiceMock.Patch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatch.PatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatch.PatchMock.defaultExpectation.results
		if mm_results == nil {
			mmPatch.t.Fatal("No results are set for the UserServiceMock.Patch")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmPatch.funcPatch != nil {
		return mmPatch.funcPatch(ctx, userData, id)
	}
	mmPatch.t.Fatalf("Unexpected call to UserServiceMock.Patch. %v %v %v", ctx, userData, id)
	return
}

// PatchAfterCounter returns a count of finished UserServiceMock.Patch invocations
func (mmPatch *UserServiceMock) PatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.afterPatchCounter)
}

// PatchBeforeCounter returns a count of UserServiceMock.Patch invocations
func (mmPatch *UserServiceMock) PatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatch.beforePatchCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Patch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatch *mUserServiceMockPatch) Calls() []*UserServiceMockPatchParams {
	mmPatch.mutex.RLock()

	argCopy := make([]*UserServiceMockPatchParams, len(mmPatch.callArgs))
	copy(argCopy, mmPatch.callArgs)

	mmPatch.mutex.RUnlock()

	return argCopy
}

// MinimockPatchDone returns true if the count of the Patch invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockPatchDone() bool {
	if m.PatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchMock.invocationsDone()
}

// MinimockPatchInspect logs each unmet expectation
func (m *UserServiceMock) MinimockPatchInspect() {
	for _, e := range m.PatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Patch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchCounter := mm_atomic.LoadUint64(&m.afterPatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchMock.defaultExpectation != nil && afterPatchCounter < 1 {
		if m.PatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Patch at\n%s", m.PatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Patch at\n%s with params: %#v", m.PatchMock.defaultExpectation.expectationOrigins.origin, *m.PatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatch != nil && afterPatchCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Patch at\n%s", m.funcPatchOrigin)
	}

	if !m.PatchMock.invocationsDone() && afterPatchCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Patch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchMock.expectedInvocations), m.PatchMock.expectedInvocationsOrigin, afterPatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockPatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockPatchDone()
}
